#!/usr/local/bin/python3

# rackcli - commandline supplemnt for VCV Rack w/ rackshim dependency

from pathlib import Path
from hashlib import sha256
from fuzzywuzzy import fuzz, process
import os, sys, subprocess, shutil, json, click

def rackdir(): # os-specific VCV Rack installation directory
    return({'darwin': Path.home() / 'Documents/Rack', 'linux': Path.home() / '.rack',
        'win32': Path.home() / 'My Documents/Rack'}[sys.platform])

def meta2hash(): # hash libs/modification timestamps
    fingerprint = ''
    for p in (rackdir() / 'plugins').rglob('plugin.*'):
        fingerprint += str(p) + '@' + str(p.stat().st_mtime)
    return(sha256(fingerprint.encode('utf-8')).hexdigest())

def meta2json(): # realize timely meta (rack plugin module metadata) as json
    metahash = rackdir() / 'meta.hash'; metajson = rackdir() / 'meta.json'
    if not metahash.is_file(): metahash.touch(mode=0o700)
    if metahash.read_text() == meta2hash():
        return(json.loads(metajson.read_text()))
    else:
        metahash.write_text(meta2hash())
        meta = subprocess.getoutput('rackshim') # assumes pathed rackshim
        metajson.write_text(meta)
        return(json.loads(meta))

settings = json.loads((rackdir() / 'settings.json').read_text())
meta = meta2json()

@click.group()
def cli():
    '''rackcli, v0.1.0

    \b
    Supplemental tooling incubator for VCV Rack.

    \b
    https://github.com/dirkleas/rackcli
    dirkleas@gmail.com
    '''
    pass

@cli.command()
@click.option('--backup/--no-backup', default=False, help='Optionally backup changed patch.')
@click.argument('patch', type=click.Path(exists=True), default=settings['lastPath'])
def fix(patch, backup):
    '''Attempt fuzzy plugin slug name fix on PATCH.'''
    updated = False
    patch = Path(patch)
    p = json.loads(patch.read_text())
    mm = meta2patch(meta)
    for idx, m in enumerate(p['modules']):
        if m['plugin'] == 'Core' or \
                sum(1 for _ in filter(lambda x: x['plugin'] == m['plugin'] and x['model'] == m['model'], mm)) > 0:
            continue # is version relevat?
        mm_match = list(filter(lambda x: fuzz.partial_ratio(x['plugin'], m['plugin']) > 80 and
            x['model'] == m['model'] and ver2int(x['version']) >= ver2int(m['version']), mm))
        if len(mm_match) > 0: # replace based on first match
            p['modules'][idx]['plugin'] = mm_match[0]['plugin']
            p['modules'][idx]['version'] = mm_match[0]['version']
            print('// {} updated to {} for {} module #{}, fuzzy match'.format( \
                m['plugin'], mm_match[0]['plugin'], m['model'], idx))
            updated = True
            continue
        print('// {} has no match, next steps TBD **********'.format(m['plugin'])); continue
    if updated:
        if backup: shutil.copyfile(str(patch), str(patch) + '.bak') # backup instancing?
        patch.write_text(json.dumps(p))

def meta2patch(meta): # restructure to match patch format
    mp = []
    for p in meta['plugins']:
        for m in p['models']:
            mp.append({'plugin': p['slug'], 'version': p['version'], 'model': m['slug']})
    return(mp)

def ver2int(v): # integer version: '0.6.1' => 61, '1.0.5' => 105, strip [non-digits|.]?
    digits = list(map(lambda x: int(x), v.split('.')))
    return(sum(map(lambda x: x[0]*pow(10,x[1]), zip(digits, range(len(digits)-1, -1, -1)))))

if __name__ == '__main__':
    cli()
