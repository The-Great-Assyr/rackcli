#!/usr/local/bin/python3

# rackcli - commandline supplemnt for VCV Rack w/ rackshim dependency

from pathlib import Path
from hashlib import sha256
from fuzzywuzzy import fuzz, process
import os, subprocess, shutil, glob, json, click

rack = str(Path.home()) + '/Documents/Rack' # h4x other OSs
settings = json.loads(open(rack + '/settings.json').read())

@click.group()
def cli():
    '''rackcli, v0.1.0

    \b
    Supplemental tooling incubator for VCV Rack.

    \b
    https://github.com/dirkleas/rackcli
    dirkleas@gmail.com
    '''
    pass

@cli.command()
@click.option('--backup/--no-backup', default=False, help='Optionally backup changed patch.')
@click.argument('patch', type=click.Path(exists=True), default=settings['lastPath'])
def fix(patch, backup):
    '''Attempt fuzzy plugin slug name fix on PATCH.'''
    p = json.load(open(patch))
    updated = False
    mm = meta2patch(meta)
    for idx, m in enumerate(p['modules']):
        if m['plugin'] == 'Core' or \
                sum(1 for _ in filter(lambda x: x['plugin'] == m['plugin'] and x['model'] == m['model'], mm)) > 0:
            #print('{}:{} matches'.format(m['plugin'], m['model'])); continue
            continue # is version relevat?
        mm_match = list(filter(lambda x: fuzz.partial_ratio(x['plugin'], m['plugin']) > 80 and
            x['model'] == m['model'] and ver2int(x['version']) >= ver2int(m['version']), mm))
        if len(mm_match) > 0: # replace based on first match
            p['modules'][idx]['plugin'] = mm_match[0]['plugin']
            p['modules'][idx]['version'] = mm_match[0]['version']
            print('// {} updated to {} for {} module #{}, fuzzy match'.format( \
                m['plugin'], mm_match[0]['plugin'], m['model'], idx))
            updated = True
            continue
        print('// {} has no match, next steps TBD **********'.format(m['plugin'])); continue
    if updated:
        if backup: shutil.copyfile(patch, patch + '.bak') # backup instancing?
        json.dump(p, open(patch, 'w'))
        # print(json.dumps(patch, indent=4))

def meta2hash(): # hash libs/modification timestamps
    fingerprint = ''
    for p in glob.glob(rack + '/plugins/**/plugin.*'):
        fingerprint += p + '@' + str(os.path.getmtime(p))
    return(sha256(fingerprint.encode('utf-8')).hexdigest())

def meta2json(): # realize timely meta (rack plugin module metadata) as json
    if not Path(rack + '/meta.hash').is_file(): open(rack + '/meta.hash', 'w').close()
    if open(rack + '/meta.hash').read() == meta2hash():
        return(json.loads(open(rack + '/meta.json').read()))
    else:
        open(rack + '/meta.hash', 'w').write(meta2hash())
        meta = subprocess.getoutput('rackshim') # assumes pathed rackshim
        open(rack + '/meta.json', 'w').write(meta)
        return(json.loads(meta))

def meta2patch(meta): # restructure to match patch format
    mp = []
    for p in meta:
        for m in p['models']:
            mp.append({'plugin': p['slug'], 'version': p['version'], 'model': m['slug']})
    return(mp)

def ver2int(v): # integer version: '0.6.1' => 61, '1.0.5' => 105, strip [non-digits|.]?
    digits = list(map(lambda x: int(x), v.split('.')))
    return(sum(map(lambda x: x[0]*pow(10,x[1]), zip(digits, range(len(digits)-1, -1, -1)))))

if __name__ == '__main__':
    meta = meta2json()
    cli()
